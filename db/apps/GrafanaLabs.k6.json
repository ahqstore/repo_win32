{"appId":"w:GrafanaLabs.k6","appShortcutName":"k6","appDisplayName":"k6","authorId":"w:winget","releaseTagName":"winget-1.3.0","downloadUrls":{"0":{"installerType":"WindowsInstallerMsi","asset":"","url":""},"1":{"installerType":"WindowsInstallerMsi","asset":"","url":"https://github.com/grafana/k6/releases/download/v1.3.0/k6-v1.3.0-windows-amd64.msi"}},"install":{"win32":{"assetId":1,"exec":null,"scope":"Machine","installerArgs":null},"winarm":null,"linux":null,"linuxArm64":null,"linuxArm7":null,"android":null},"displayImages":[],"description":"A modern load testing tool, using Go and JavaScript.\n\nk6 is a developer-centric, free and open-source load testing tool built for making performance testing a productive and enjoyable experience. Using k6, you\"ll be able to catch performance regression and problems earlier, allowing you to build resilient systems and robust applications.\nk6 v1.3.0 is here ðŸŽ‰! This release includes:\n- Browser module gets:\n  - locator.locator, locator.contentFrame, and FrameLocator.locator for powerful locator chaining and iframe handling.\n  - locator|frame|FrameLocator.getBy* for targeting elements without relying on brittle CSS selectors.\n  - locator.filter for filtering locators for more precise element targeting.\n  - locator.boundingBox for retrieving element geometry.\n  - page.waitForResponse for waiting on specific HTTP responses.\nDeprecations\nA new summary mode disabled has been introduced to replace the \"no summary\" option #5118\nThe --no-summary flag and its corresponding environment variable K6_NO_SUMMARY have been deprecated in favor of\nthe new disabled summary mode. This change unifies the configuration experience for controlling the end-of-test summary.\nYou can now disable the end-of-test summary with either --summary-mode=disabled or K6_SUMMARY_MODE=disabled.\nThe legacy summary mode has been deprecated #5138\nThe legacy summary mode was introduced in k6 v1.0, when the end-of-test summary was revamped with the addition of two\nnew modes: compact and full.\nIts purpose was to ease the transition for users who relied heavily on the old summary format.\nHowever, weâ€™ve now reached the point where itâ€™s time to deprecate it.\nThe plan is to fully remove it in k6 v2.0, so please migrate to either compact or full to ensure readiness for the\nnext major release.\nNew features\nlocator.locator #5073\nThe locator.locator method allows you to define locators relative to a parent locator, enabling powerful locator chaining and nesting. This feature lets you create more precise element targeting by combining multiple selectors in a hierarchical manner.\nawait page\n  .locator('[data-testid=\"inventory\"]')\n  .locator('[data-item=\"apples\"]')\n  .locator('button.add')\n  .click();\nThis nesting capability provides a more intuitive way to navigate complex DOM structures and serves as the foundation for other locator APIs in this release that require such hierarchical targeting.\nlocator.contentFrame #5075\nThe browser module now supports locator.contentFrame(), which returns a new type frameLocator. This method is essential for switching context from the parent page to iframe contents.\nframeLocator types target iframe elements on the page and provide a gateway to interact with their contents. Unlike regular locators that work within the current frame context, frameLocators specifically target iframe elements and prepare them for content interaction.\nThis approach is essential for iframe interaction because:\n- Iframes create separate DOM contexts that require special handling.\n- Browsers enforce security boundaries between frames.\n- Iframe content may load asynchronously and needs proper waiting.\n- Using elementHandle for iframe interactions is error-prone and can lead to stale references, while frameLocator provide reliable, auto-retrying approaches.\nExample usage:\n// Get iframe element and switch to its content frame\nconst iframeLocator = page.locator('iframe[name=\"payment-form\"]');\nconst frame = await iframeLocator.contentFrame();\nframeLocator.locator #5075\nWe've also added frameLocator.locator which allows you to create locators for elements inside an iframe. Once you've targeted an iframe with page.contentFrame(), you can use .locator() to find and interact with elements within that iframe's content with the frameLocator type.\nExample usage:\n// Target an iframe and interact with elements inside it\nconst iframe = page.locator('iframe[name=\"checkout-frame\"]').contentFrame();\nawait iframe.locator('input[name=\"card-number\"]').fill('4111111111111111');\nawait iframe.locator('button[type=\"submit\"]').click();\nThis functionality enables testing of complex web applications that use iframes for embedded content, payment processing, authentication widgets, and third-party integrations.\nlocator.boundingBox #5076\nThe browser module now supports locator.boundingBox(), which returns the bounding box of an element as a rectangle with position and size information. This method provides essential geometric data about elements on the page, making it valuable for visual testing, and layout verification.\nUsing locator.boundingBox() is recommended over elementHandle.boundingBox() because locators have built-in auto-waiting and retry logic, making them more resilient to dynamic content and DOM changes. While element handles can become stale if the page updates, locators represent a live query that gets re-evaluated, ensuring more reliable test execution.\nThe method returns a rectangle object with x, y, width, and height properties, or null if the element is not visible:\n// Get bounding box of an element\nconst submitButton = page.locator('button[type=\"submit\"]');\nconst rect = await submitButton.boundingBox();\nLocator filtering #5114, #5150\nThe browser module now supports filtering options for locators, allowing you to create more precise and reliable element selections. This enhancement improves the robustness of your tests by enabling you to target elements that contain or exclude specific text, reducing reliance on brittle CSS selectors.\nlocator.filter() creates a new locator that matches only elements containing or excluding specified text.\n// Filter list items that contain specific text\nconst product2Item = page\n  .locator('li')\n  .filter({ hasText: 'Product 2' });\n// Filter items that do NOT contain specific text using regex\nconst otherProducts = page\n  .locator('li')\n  .filter({ hasNotText: /Product 2/ });\nIt's also possible to filter locators during their creation with options.\npage.locator(selector, options) creates page locators with optional text filtering:\n// Create locators with text filtering during creation\nconst submitButton = page.locator('button', { hasText: 'Submit Order' });\nawait submitButton.click();\nframe.locator(selector, options) creates frame locators with optional text filtering:\n// Filter elements within frame context\nconst frame = page.mainFrame();\nconst input = frame.locator('input', { hasNotText: 'Disabled' });\nlocator.locator(selector, options) chains locators with optional text filtering:\n// Chain locators with filtering options\nawait page\n  .locator('[data-testid=\"inventory\"]')\n  .locator('[data-item=\"apples\"]', { hasText: 'Green' })\n  .click();\nframeLocator.locator(selector, options) create locators within iframe content with optional text filtering:\n// Filter elements within iframe content\nconst iframe = page.locator('iframe').contentFrame();\nawait iframe.locator('button', { hasText: 'Submit Payment' }).click();\nframe.getBy*, locator.getBy*, frameLocator.getBy* #5105, #5106, #5135\nThe browser module now supports all getBy* methods on frame, locator, and frameLocator types, expanding on the page.getBy* APIs introduced in v1.2.1. This enhancement provides consistent element targeting across all browser automation contexts, improving Playwright compatibility and offering more flexible testing workflows. The available methods on all types are:\n- getByRole() - Find elements by ARIA role\n- getByText() - Find elements by text content\n- getByLabel() - Find elements by associated label text\n- getByPlaceholder() - Find elements by placeholder text\n- getByAltText() - Find elements by alt text\n- getByTitle() - Find elements by title attribute\n- getByTestId() - Find elements by data-testid attribute\nExamples across different types\n// Frame context\nconst frame = page.mainFrame();\nawait frame.getByRole('button', { name: 'Submit' }).click();\nawait frame.getByLabel('Email').fill('user@example.com');\n// Locator context (for scoped searches)\nconst form = page.locator('form.checkout');\nawait form.getByRole('textbox', { name: 'Card number' }).fill('4111111111111111');\nawait form.getByTestId('submit-button').click();\n// FrameLocator context (for iframe content)\nconst paymentFrame = page.locator('iframe').contentFrame();\nawait paymentFrame.getByLabel('Cardholder name').fill('John Doe');\nawait paymentFrame.getByRole('button', { name: 'Pay now' }).click();\n// Chaining for precise targeting\nawait page\n  .locator('.product-list')\n  .getByText('Premium Plan')\n  .getByRole('button', { name: 'Select' })\n  .click();\nThis expansion makes k6 browser automation more versatile and aligns with modern testing practices where element targeting by semantic attributes (roles, labels, text) is preferred over fragile CSS and XPath selectors.\npage.waitForResponse #5002\nThe browser module now supports page.waitForResponse(), which allows you to wait for HTTP responses that match specific URL patterns during browser automation. This method is particularly valuable for testing scenarios where you need to ensure specific network requests complete before proceeding with test actions.\nThe method supports multiple URL pattern matching strategies:\n// Wait for exact URL match\nawait page.waitForResponse('https://api.example.com/data');\n// Wait for regex pattern match\nawait page.waitForResponse(/\\/api\\/.*\\.json$/);\n// Use with Promise.all for coordinated actions\nawait Promise.all([\n  page.waitForResponse('https://api.example.com/user-data'),\n  page.click('button[data-testid=\"load-user-data\"]')\n]);\nThis complements the existing waitForURL method by focusing on HTTP responses rather than navigation events, providing more granular control over network-dependent test scenarios.\nThank you, @HasithDeAlwis, for contributing this feature.\nUX improvements and enhancements\n- #5117 Unifies unauthenticated errors for Cloud commands.\n- #5125 Changes a warn log to a debug when a worker type is used on a website under test.\n- #5111 Adds retries to actionability based APIs (locator) when elements aren't visible.\n- #5004 Removes undefined headers from route.continue/fulfill.\n- #4984 Adds link to documentation in k6 --help output. Thank you, @Nishant891 for the change.\nBug fixes\n- #5079 Fixes version of k6 when it is built with xk6.\n- #5057 Fixes a panic on the deprecated k6 login cloud command. Thanks @indygriffiths for reporting it!","repo":{"author":"microsoft","repo":"winget-pkgs"},"version":"1.3.0","site":"https://grafana.com/","source":"Grafana Labs","license_or_tos":"AGPL-3.0","resources":null,"verified":false}