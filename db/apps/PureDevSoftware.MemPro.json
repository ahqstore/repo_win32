{"appId":"w:PureDevSoftware.MemPro","appShortcutName":"MemPro","appDisplayName":"MemPro","authorId":"w:winget","releaseTagName":"winget-1.6.11.0","downloadUrls":{"0":{"installerType":"WindowsInstallerMsi","asset":"","url":""},"1":{"installerType":"WindowsInstallerMsi","asset":"","url":""}},"install":{"win32":null,"winarm":null,"linux":null,"linuxArm64":null,"linuxArm7":null,"android":null},"displayImages":[],"description":"C++ Memory Profiler\n\nMemPro is a C++ memory profiler. MemPro runs on Windows platforms, but can connect to and profile applications on almost any platform. MemPro particularly stands out from other C++ memory profilers for its ability to handle very large data sets.\n\nGetting Started\nIntegrate MemPro into your codebase in minutes - simply add MemPro.cpp/h into your code and you will be able to connect to your application with MemPro. Once connected MemPro allows you to visualise your memory usage in a number of different ways.\n\nWhy MemPro?\nMemPro can handle massive data sets. Profiles of trillions of allocations are not uncommon. MemPro is also perfect for profiling real-time applications such as games because of its minimal overhead. Because all of the processing is offline, MemPro can track thousands of allocations per second without noticeable slowdown.\n\nFeatures\n- Full memory breakdown of your application\n- Multiple views of the data\n- Easily find and fix memory leaks\n- Subtract one snapshot from another\n- Rewind memory\n- Virtual memory layout visualisation\n- Visualise memory fragmentation\n- Profile applications of any size quickly and efficiently\n\nHow it works\nMemPro supplies two macros: MEMPRO_TRACK_ALLOC(p, size) and MEMPRO_TRACK_FREE(p). For ease of use MemPro automatically overrides the global new and delete operators and adds these macros, but if you have your own allocation routines then you can add the macros yourself as needed. MemPro records the callstack of every allocation, and all of the data is sent over the network to MemPro.\nMemPro processes the data offline. All the current live allocations are tracked. When a matching free is found the allocation is removed. MemPro also stores an entire history of all allocations and frees which allows for retrospective snapshots and rewinding of memory.\nAll of the symbol lookups are done by MemPro, which keeps the overhead in your application to a minimum. MemPro will read the symbol files for your application and display the callstacks.\nThe main way of viewing data in MemPro is to take a snapshot at a specific point in time. This shows you all of the allocations that are live at that point. You can this view the data in multiple ways, such as the calltree view and the types view.\nFor finding memory leaks or memory spikes, you can subtract one snapshot from another snapshot. This shows you all allocations that are in the second snapshot but not in the first.\nMemPro has a powerful feature specifically for tracking down memory leaks. It can analyse the entire contents of the application's memory and find any allocations that are not referenced by any code or data. It also uses a sophisticated set of heuristics to analyse the allocation pattern of each callstack to check for possible leaks.\nMemPro is particularly valuable for tracking down memory corruption bugs. MemPro can show you the entire history of all allocations and frees that happened in a specific address range. This is often sufficient information to find the cause of the corruption.\nMemPro is quick to integrate, has low overhead and is ideal for profiling real-time applications such as games. With MemPro you can easily see where your memory is going, you can track down leaks and spikes in minutes and find those hard-to-track-down memory corruption bugs.\n- MemPro.cpp linux fixes","repo":{"author":"microsoft","repo":"winget-pkgs"},"usrVersion":"1.6.11.0","version":0,"site":"https://www.puredevsoftware.com/","source":"PureDev Software","license_or_tos":"Proprietary","resources":null,"verified":false}